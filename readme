顺序表：（静态数组，动态数组（扩容））
    增：在插入的索引处，索引及索引后的元素均往后移一位，最后先移
    删：在删除的索引处，索引以后的元素往前移一位
    扩容及缩容：元素个数与容量相等时，输入容量2倍，然后将原数组的元素复制到新数组中
        增时先判断要不要扩容，在添加元素；删除时先删元素，在判断要不要缩容
    时间复杂度
        增：addlast O(1),addfirst O(n),add(index,e) O(n)；resize O(n)；
        删：removelast O(1),removefirst O（n）,remove(index,e) O(n);resize O(n);
        改：set（index,e）O(1);
        查：get（index）O(1);contains（e）O(n);find(e) O(n)

        容量n，n+1次addlast，触发resize，n+1+n，addlast均摊复杂度O(1),removelast也是
        一个耗时操作如扩缩容，不是每次都触发，使用均摊复杂度

        复杂度震荡：扩缩容临界增删，addlast，removelast都是O（n）；原因removelast时resize过于着急，lazy，size==capacity/4，才减半


        顺序表队列
            普通队列，用现成顺序表，尾进首出 enqueueO（1）均摊，dequeueO（n）

            循环队列，保证进出都是均摊O(1)，重新建立顺序表(指针front,tail,忘了)，从空的开始计
                空队列front==tail，队列满（tail+1）%c==front，进队列，判断满美满，当前tail输入值，tail+1,，;出队列，data[front]=None，front+1


        顺序表栈，用现成顺序表（尾进尾出）push，pop均摊复杂度O（1），涉及到扩缩容


链表：
    添加虚拟节点，添加元素、删除元素时，for i in range(index)正好找到索引节点的前一个节点
    获得索引元素、修改索引元素，curr=dummy_node.next,for i in range(index),正好找到所要节点
    是否包含，while循环

        链表队列(尾入头出)，重新建立链表（指针head,tail指向节点,也就是说他们代表节点）
            因为有索引，从两端插入元素都是很容易的，但尾部删除节点不容易，因为删除要找到元素前一个节点，尾部办不到
            从head端删除，从tail端插入元素
            教学中链表队列没有使用虚拟节点
            #head,tail都为空，添加后，head与tail指向同一个节点
            入队：tail为空，代表队列对空，维护tail
                    #head,tail都为空，添加后，head与tail指向同一个节点
            出队：返回头结点，头结点指空；如果队列仅一个元素，出队后head，tail为空
            出入各两种情况，
        链表栈，用现成链表（头进头出）O（1）

    注意：顺序表循环队列tail指向最后元素的下一个，链表队列tail指向最后一个元素

    递归还是不太懂，链表删除固定元素值，这个要看看
    顺序表与链表差别：顺序表快速查询，链表动态（不需要扩容），


二分搜索树，存储的元素必须有可比较性
        二叉树：具有唯一根节点，每个节点最多分成两个子节点
        满二叉树：除叶子节点，其余节点挂满
        二分搜索树每个节点值大于左子树，小于右子树
    用递归，解决了根节点为空

    先序（递归）栈，层次（队列）

    删除时要维护结构，不是单单找到元素删掉
    删除任意元素
        删除只有左孩子的节点，该节点的左子树取代它的位置
        删除只有右孩子的节点，该节点的右子树取代它的位置
        删除左右都有孩子的节点 ，找该节点的右子树最小节点取代它
    时间复杂度
        增删查 平均 O（logn）
        二分搜索树最坏情况，退化成链表 增删查O（n）
    二分搜索树因其特性，没有改值方法

优先队列
    普通线性结构：入队O(1),出队O（n）
    有序线性结构：入队O（n），出队O（1）
    堆：入队，出队 最差O（logn）

    堆
    # 二叉堆是完全二叉树，缺失节点在整棵树的右下侧，完全二叉树把元素从左到右一层一层铺，数组可以表示，二叉树也能表示
    # 解决问题：寻找孩子节点，有图得出规律
    # 重要性质：（最大堆）父节点值大于等于子节点，大小与层次无关系

    数组存储二叉堆
    parent=（i-1）/2
    left_child=2i+1
    right_child=2*i+2

    #堆中两个重要操作：上浮，下沉
    #上浮：数组尾端加入后，找到元素父节点索引，比较元素大小，进行交换，交换后在于其父节点比较，循环
    #下沉：取完最大值后下沉，先把最后元素放入首端，删除最后元素，取两个子节点最大元素，与其交换，循环
        下沉循环条件：k左孩子索引<数组元素个数，否则说明k为叶结点
    #堆常用操作：
    # Heapify：将任意数组整理成堆。1.将n个元素逐个插入到空堆中，算法复杂度是O（nlogn）
    #          2.将数组元素按顺序排列，看成完全二叉树，
                    从最后一个非叶子节点（最后元素索引的父节点）开始，对之前每一个节点（倒序）进行下沉操作(O(n))；
                         最后变成最大堆
    # replace（取最大后并放新）：1.可以先取最大（下沉），取完后放入（上浮），两次O(logn)操作；
                              2.堆顶元素直接替换为新的元素，然后下沉O(logn)

递归：
计算，排序，树结构
不需要返回值，快速排序
需要返回值，归并排序，树，计算


集合与映射
集合，不添加重复元素；
    BST，linkedlist 直接用就可实现
        二分搜索树实现集合，我们写的二分搜索树不添加重复元素
            O（logn）
        链表实现集合，需要判别是否重复；
            增On，因为判断是否重复；查On，remove On；

映射
    映射就是字典（key，value），存储数据对的数据结构，注意：key是唯一的
        链表拿过来改，需要建立辅助函数get_node，根据key获得节点，为增删改查做铺垫
            链表增是按索引增，所以链表没有初始化next；
            映射中的链表只在头部增，，映射初始化next，用于插入节点的指向
            链表基于索引，映射基于key，只能用while

            增：先确认是否有key
        BST拿过来改一改,key必须有可比性,

#AVL树：在二分搜索树结构基础上，添加自平衡机制；解决二分搜索树退化成链表这种坏情况
#平衡二叉树：对于任一一个节点，左子树与右子树的高度差不超1；满二叉树，完全二叉树，都是
#堆保证叶子节点高度差不超1，更严格
#平衡二叉树高度与节点数量之间关系O（logn）
#节点高度：左右子树大的高度+1
#节点的平衡因子：该节点的左右子树高度差
#什么时候维护平衡：插入节点的祖先节点高度值更新，导致平衡因子破坏，向其祖先节点回溯维护平衡（沿着节点向上维护平衡性，上一层维护）
    左右旋转时要维护高度
    左左（当前节点平衡因子>1，左子树平衡因子>=0）：右旋转
    右右：左旋转
    左右：当前节点的左子树进行左旋转，在对当前节点右旋转
    右左：
AVL树在二分搜索树基础上，只对增删时维护自平衡，其他方法不变

AVL树也可以实现集合与映射

    在节点中新增高度属性
    方法：获得节点高度值
        递归：添加节点时维护高度值
    方法：计算平衡因子
        递归：调用计算平衡因子方法
    方法：判断是否是二分搜索树， 中序遍历，所有元素按顺序排列
    方法：判断是否平衡
    remove里维护平衡，不要remove_min


哈希表
    哈希冲突：key通过哈希函数转换成的 索引相同
    哈希表：空间换时间
    哈希函数设计很重要，索引越分布越均匀越好，哈希函数把类型转成整型，随后自己对素数取模，成为数组索引，在对应索引存储key，value
        原则：一致性a==b，hash（a）==hash（b）高效，均匀
    大整数，模一个素数
    浮点转整型取模
    字符串转整型取模，字符串转成整型可能溢出，所以每层取模
    复合类型（年月日）

    哈希冲突处理：链地址法
    哈希表本质上就是一个数组，取模的素数是哈希表的长度，每个元素是一个map or set

    哈希表key不唯一，但是元素为map中key唯一；重复改

    数组长m，元素个数n，每个位置的map有n/m个元素
    数组元素为链表，时间复杂度O（n/m）
            tree,O(LOG(N/M))
    上面是平均复杂度，
    最坏情况：所有元素挤在一个索引处（通常不会发生 ）哈希碰撞 ：搞到哈希函数，设计数据，，拖慢系统速度

    哈希表的动态空间处理
        让哈希表均摊复杂度达到O(1)，M为动态，随着n改变m自适应
        平均每个地址承载的元素多过一定程度，扩容  n/m 值大于等于某值
        平均每个地址承载的元素少过一定程度，缩容

        建立素数表（M大小），取代翻倍size
    哈希表失去顺序性
    哈希表也能实现集合映射
        有序（树），无序（哈希表）



下面的树结构，终端节点（最底层），叶子节点（空）
红黑树
    #红黑树性质：
        根黑；空黑（空节点，叶子节点的下一层 ）；
        若父红，则子黑；父黑，右孩子为黑
        （黑平衡）任意节点至叶节点，经过的黑节点数目相同；但是红黑是不是平衡二叉树
        红黑树是二分搜索树
    23树绝对平衡（根-叶深度相同），红黑树是黑平衡(不是平衡二叉树)O（logn）

    23树：节点有2或3个孩子
    23树满足二分搜索树的基本性质（左子树《根《右子树），但不是二叉树

    23树如何维持绝对平衡：
        添加节点永远不会添加到空的节点；融合成四节点，分裂；
           首个四节点分裂成3个二节点，后面的四节点分裂成3个二节点，上面节点与其父节点融合（保持绝对平衡）
            #插入3节点，其父2节点；分裂融合
            #插入3节点，其父3节点；分裂融合，父成4节点，分裂，一直向上推，直到根节点

    红黑树与23树等价
        红黑树把3节点‘bc’拆成2个2节点，b子c父，b红c黑；也就是红色节点左倾斜
        任意一颗23树可以转化成红黑树

    红黑树实现：
        红黑树改二分搜索树代码
        新属性color
        初始化节点为甚默认是红色？
            23树添加节点首要就是融合，红黑树与23树等价，红色代表添加时融合


    红黑树最大高度2logn，增删改查O（logn）：查比AVl慢一些，增删比AVL快
    为什么？




B树（磁盘存取，数据库）
    二分搜索树（二叉排序树）二路查找，B树是多路查找
    平衡二叉树（AVL），一个节点放一个元素，元素过多还是树的深度还是很深，查找还是很慢
    B树与2-3树一样添加元素始终与叶结点融合
    B树是一颗平衡多叉树（绝对平衡？是的），一个节点放多个元素，每个节点多颗子树（M阶=节点最大子树数目）
        性质：关键字（元素）M阶
            2.根节点至少有一个元素
            3.M阶，除根、非叶结点，每个节点元素至少m/2 -1个，子树m/2；至多m-1个
            4.所有叶子节点在同一层，不带信息？

    B树操作：
        插入：先确认阶数，确定节点最大融合数（这边可以看红黑树的插入过程）
            融合，分裂
        删除：满足节点关键字数量至少m/2-1
            删除的关键字在终端节点：
                1.节点关键字数量大于最小值，直接删除
                 2.           等于，兄弟节点中存在关键字数量大于最小值，去兄弟节点中借关键字（替换）
                  3.          等于，兄弟节点中关键字数量<=最小值，节点融合（取上一层节点与兄弟节点合并）

            非终端节点删除：
                相邻关键字，非终端节点，其左子树中值最大的关键字或右子树中值最小关键字
                先转换成终端节点，按照终端节点删除操作
                1.左子树或右子树存在关键字数量>最小值,找到其相邻关键字，互换；把待删除节点搞到终端节点上
                2.左右子树关键字数量=最小值，左右子树合并，删除待删除关键字（或将待删除节点与终端节点交换，）






        查找（最关键）：与二分搜索树查找思路一样
            通过待查找关键字与节点中的关键字比较



    删除时保证节点n元素，n+1颗树
    下依上，动的话动下面层

B+树与B树对比：
    数据库和操作系统的文件系统中的一种用于查找的数据结构
    节点元素n个，n棵子树
    非根元素个数与阶的关系：B+树m/2~m;    B树m/2-1 ~ m-1
                        根元素1~m；    1~m-1

    B+树中，非叶子节点仅起到索引作用（记录子树最大关键字，指针）叶结点包含信息（数据信息指针（存储地址）
    而B树中每一个指向一个记录的存储地址

    B+树中，叶结点包含全部关键字（非叶结点中出现的关键字也会出现子叶节点中，而叶子节点指针指向记录）
    而B树中，叶子节点包含的关键字和其他节点包含的关键字不重复，每个关键字都对应记录

    B+树中，叶子节点连接成单链表，并有一个指针指向关键字最小的叶子节点，可以对数据库记录顺序查找





